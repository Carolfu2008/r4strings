{
    "collab_server" : "",
    "contents" : "# Character Sets\n\nIn this chapter we will talk about character sets. You will learn about \na couple of more metacharacters, the opening and closing brackets `[ ]`, that \nwill help you define a character set.\n\nThese square brackets indicate a character set which will match any one of \nthe various characters that are inside the set. Keep in mind that a character \nset will match only one character. The order of the character inside the set \ndoes not matter; what matter is just the presence of the characters inside the\nbrackets. So for example if you have a set defined by `\"[AEIOU]\"`, that will \nmatch any one upper case vowel. \n\n\n## Defining character sets\n\nConsider the following pattern that includes a character set: `\"p[aeiou]n\"`, \nand a vector with the words _pan_, _pen_, and _pin_:\n\n```{r results='hide'}\npns <- c('pan', 'pen', 'pin', 'pon', 'pun')\n\nstr_view(pns, \"p[aeiou]n\")\n```\n\nThe set `\"p[aeiou]n\"` matches all elements in `pns`. Now let's use the same \nset with another vector `pnx`:\n\n```{r results='hide'}\npnx <- c('pan', 'pen', 'pin', 'p0n', 'p.n', 'p1n', 'paun')\n\nstr_view(pnx, \"p[aeiou]n\")\n``` \n\nAs you can tell, this time only the first three elements in `pnx` are matched.\nNotice also that _paun_ is not matched. This is because the character set\nmatches only one character, either _a_ or _u_ but not _au_.\n\nIf you are interested in matching all capital letters, you can defined a set\nformed as:\n\n```\n[ABCDEFGHIJKLMNOPQRSTUVWXYZ]\n```\n\nLikewise, you can define a set with only lower case letters:\n\n```\n[abcdefghijklmnopqrstuvwxyz]\n```\n\nIf you are interested in matching any digit, you can also specify a character\nset like this:\n\n```\n[0123456789]\n```\n\n\n\n## Character ranges\n\nThe previous examples that show character sets containing all the capital \nletters or all lower case letters are very convenient but require a lot of \ntyping. __Character ranges__ are going to help you solve that problem, by \ngiving you a convenient shortcut based on the dash metacharacter `\"-\"` to \nindicate a range of characters. A character range consists of a character set\nwith two characters separated by a dash or minus `\"-\"` sign.\n\nLet's see how you can reexpress the examples in the previous section as\ncharacter ranges. The set of all digits can be expressed as a character range\nusing the following pattern:\n\n```\n[0-9]\n```\n\nLikewise, the set of all lower case letters _abcd...xyz_ is compactly \nrepresented with the character range:\n\n```\n[a-z]\n```\n\nAnd the character set of all upper case letters _ABD...XYZ_ is formed by\n\n```\n[A-Z]\n```\n\nNote that the dash is only a metacharacter when it is inside a character set; \noutside the character set it is just a literal dash.\n\nSo how do you use character range? To illustrate the concept of character \nranges let's create a `basic` vector with some simple strings, and see \nwhat the different ranges match:\n\n```{r}\nbasic <- c('1', 'a', 'A', '&', '-', '^')\n```\n\n```{r results='hide'}\n# digits\nstr_view(basic, '[0-9]')\n```\n\n```{r results='hide'}\n# lower case letters\nstr_view(basic, '[a-z]')\n```\n\n```{r results='hide'}\n# upper case letters\nstr_view(basic, '[A-Z]')\n```\n\nNow consider the following vector `triplets`:\n\n```{r}\ntriplets <- c('123', 'abc', 'ABC', ':-)')\n```\n\nYou can use a series of character ranges to match various occurrences of\na certain type of character. For example, to match three consecutive digits\nyou can define a pattern `\"[0-9][0-9][0-9]\"`; to match three consecutive\nlower case letters you can use the pattern `\"[a-z][a-z][a-z]\"`; and the\nsame idea applies to a pattern that matches three consecutive upper case\nletters `\"[A-Z][A-Z][A-Z]\"`. \n\n```{r results='hide'}\nstr_view(triplets, '[0-9][0-9][0-9]')\n\nstr_view(triplets, '[A-Z][A-Z][A-Z]')\n```\n\nObserve that the element `\":-)\"` is not matched by any of the character ranges\nthat we have seen so far.\n\nCharacter ranges can be defined in multiple ways. For example, the range \n`\"[1-3]\"` indicates any one digit 1, 2, or 3. Another range may be defined\nas `\"[5-9]\"` comprising any one digit 5, 6, 7, 8 or 9. The same idea applies\nto letters. You can define shorter ranges other than `\"[a-z]\"`. One example\nis `\"[a-d]\"` which consists of any one lettere _a_, _b_, _c_, and _d_.\n\n\n## Negative Character Sets\n\nA common situation when working with regular expressions consists of matching\ncharacters that are NOT part of a certain set. This type of matching can be\ndone using a negative character set: by matching any one character that is not\nin the set. To define this type of sets you are going to use the metacharacter\ncaret `\"^\"`. If you are using a QWERTY keyboard, the caret symbol should be\nlocated over the key with the number 6.\n\nThe caret `\"^\"` is one of those metacharacters that have more than one meaning\ndepending on where it appears in a pattern. If you use a caret in the first\nposition inside a character set, e.g. `[^aeiou]`, it means _negation_. In \nother words, the caret in `[^aeiou]` means \"not any one of lower case vowels.\"\n\nLet's use the `basic` vector previously defined:\n\n```{r}\nbasic <- c('1', 'a', 'A', '&', '-', '^')\n```\n\nTo match those elements that are NOT upper case letters, you define a negative\ncharacter range `\"[^A-Z]\"`:\n\n```{r results='hide'}\nstr_view(basic, '[^A-Z]')\n```\n\nIt is important that the caret is the first character inside the character \nset, otherwise the set is not a negative one:\n\n```{r results='hide'}\nstr_view(basic, '[A-Z^]')\n```\n\nIn the example above, the pattern `\"[A-Z^]\"` means \"any one upper case letter \nor the caret character.\" Which is completely different from the negative set \n`\"[^A-Z]\"` that negates any one upper case letter.\n\nIf you want to match any character except the caret, then you need to use a\ncharacter set with two carets: `\"[^^]\"`. The first caret works as a negative \noperator, the second caret is the caret character itself:\n\n```{r results='hide'}\nstr_view(basic, '[^^]')\n```\n\n\n## Metacharacters inside character sets\n\nNow that you know what character sets are, how to define character ranges, \nand how to specify negative character sets, we need to talk about what \nhappens when including metacharacters inside character sets.\n\nExcept for the caret in the first position of the character set, any other \nmetacharacter inside a character set is already escaped. This implies that\nyou do not need to escape them using backslashes.\n\nTo illustrate the use of metacharacters inside character sets, let's use \nthe `pnx` vector:\n\n```{r results='hide'}\npnx <- c('pan', 'pen', 'pin', 'p0n', 'p.n', 'p1n', 'paun')\n```\n\nThe character set formed by `\"p[ae.io]n\"` includes the dot character. Remember\nthat, in general, the period is the wildcard metacharacter and it matches \nany type of character. However, the period in this example is inside a \ncharacter set, and because of that, it loses its wildcard behavior.\n\n```{r, results='hide'}\nstr_view(pnx, \"p[ae.io]n\")\n``` \n\nAs you can tell, `\"p[ae.io]n\"` matches _pan_, _pen_, _pin_ and _p.n_, \nbut not _p0n_ or _p1n_ because the dot is the literal dot, not a wildcard \ncharacter anymore.\n\nNot all metacharacters become literal characters when they appear inside a\ncharacter set. The exceptions are the closing bracket `]`, the dash `-`,\nthe caret `^`, and the backslash `\\`.\n\nThe closing bracket `]` is used to enclose the character set. Thus, if you\nwant to use a literal right bracket inside a character set you must escape it:\n`[aei\\\\[ou]`. Remember that in R you use double backslash for escaping\npurposes. This is also why the backslash `\\`, or double backslash in R, \ndoes not become a literal character. \n\nAnother interesting case has to do with the dash or hyphen `-` character. As \nyou know, the dash inside a character set is used to define a range of \ncharacters: e.g. `[0-9]`, `[x-z]`, and `[K-P]`. As a general rule, if you\nwant to include a literal dash as part of a range, you should escape it:\n`\"[a-z\\\\-]\"`. \n\nLet's modify the `basic` vector by adding an opening and ending brackets:\n\n```{r}\nbasic <- c('1', 'a', 'A', '&', '-', '^', '[', ']')\n```\n\nHow do match each of the characters that have a special meaning inside a \ncharacter set?\n\n```{r, results='hide'}\n# matching a literal caret\nstr_view(basic, \"[a\\\\^]\")\n``` \n\n```{r, results='hide'}\n# matching a literal dash\nstr_view(basic, \"[a\\\\-]\")\n``` \n\n```{r, results='hide'}\n# matching a literal opening bracket\nstr_view(basic, \"[a\\\\[]\")\n``` \n\n```{r, results='hide'}\n# matching a literal closing bracket\nstr_view(basic, \"[a\\\\]]\")\n``` \n\n## Character Classes\n\nClosely related with character sets and character ranges, regular expressions\nprovide another useful construct called __character classes__ which, as their\nname indicates, are used to match a certain class of characters. The most\ncommon character classes in most regex engines are:\n\n| Character | Matches                                     | Same as         |\n|:----------|:--------------------------------------------|:----------------|\n| `\\\\d`     | any digit                                   | `[0-9]`         |\n| `\\\\D`     | any nondigit                                | `[^0-9]`        |\n| `\\\\w`     | any character considered part of a word     | `[a-zA-Z0-9_]`  |\n| `\\\\W`     | any character not considered part of a word | `[^a-zA-Z0-9_]` |\n| `\\\\s`     | any whitespace character                    | `[\\f\\n\\r\\t\\v]`  |\n| `\\\\S`     | any nonwhitespace character                 | `[^\\f\\n\\r\\t\\v]` |\n\n\nYou can think of character classes as another type of metacharacters, or aq \nshortcuts for special character sets. \n\nThe following table whows the characters that represent whitespaces:\n\n| Character | Description     |\n|:----------|:----------------|\n| `\\f`      | form feed       |\n| `\\n`      | line feed       |\n| `\\r`      | carriage return |\n| `\\t`      | tab             |\n| `\\v`      | vertical tab    |\n\nSometimes you have to deal with nonprinting whitespace characters. In these\nsituations you probably will end up using the whitespace character class `\\\\s`.\nA common example is when you have to match tab characters, or line breaks. \n\nThe operating system Windows uses `\\r\\n` as an end-of-line marker. In contrast,\nUnix-like operating systems (including Mac OS) use `\\n`.\n\nTab characters `\\t` are commonly as a field-separator for data files. But \nmost text editors render them as whitespaces.\n\n\n\n## POSIX Character Classes\n\nWe finish this chapter with the introduction of another type of character\nclasses known as __POSIX character classes__. These are yet another class\nconstruct that is supported by the regex engine in R.\n\n| Class        | Description                | Same as         |\n|:-------------|:---------------------------|:----------------|\n| `[:alnum:]`  | any letter or digit        | `[a-zA-Z0-9]`   |\n| `[:alpha:]`  | any letter                 | `[a-zA-Z]`      |\n| `[:digit:]`  | any digit                  | `[0-9]`         |\n| `[:lower:]`  | any lower case letter      | `[a-z]`         |\n| `[:upper:]`  | any upper case letter      | `[A-Z]`         |\n| `[:space:]`  | any whitespace inluding space | `[\\f\\n\\r\\t\\v ]` | \n| `[:punct:]`  | any punctuation symbol     |                 |\n| `[:print:]`  | any printable character    |                 |\n| `[:graph:]`  | any printable character excluding space |    |\n| `[:xdigit:]` | any hexadecimal digit      | `[a-fA-F0-9]`   |\n| `[:cntrl:]`  | ASCII control characters   |                 |\n",
    "created" : 1479442707916.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1319720328",
    "id" : "3B0307AF",
    "lastKnownWriteTime" : 1479447008,
    "last_content_update" : 1479447008350,
    "path" : "~/Dropbox/r4strings/character-sets.Rmd",
    "project_path" : "character-sets.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}
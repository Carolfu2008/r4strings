# Character Strings in R {#chars}

In R, a piece of text is represented as a sequence of characters (letters, 
numbers, and symbols). The data type R provides for storing sequences of 
characters is _character_. Formally, the class of object that holds 
character strings in R is `"character"`.

We express character strings by surrounding text within single quotes:

```{r eval=FALSE}
'a character string using single quotes'
```

or we can also surround text within double quotes:

```{r eval=FALSE}
"a character string using double quotes"
```

The important thing is that we must match the type of quotes that we are using. 
A starting single quote must have an ending single quote. Likewise, a string 
with an opening double quote must be closed with a double quote. 

Typing characters in R like in above examples is not very useful. Typically, 
we are going to create objects or variables containing some strings. For 
example, we can create a variable `string` that stores some string:

```{r}
string <- 'string'
string
```

Notice that when you print a character object, R displays it using double quotes 
(regardless of whether the string was created using single or double quotes). 
This allows us to quickly identify when an object contains character strings.

When writing strings, we can insert single quotes in a string with double 
quotes, and vice versa:

```{r eval=FALSE}
# single quotes within double quotes
"The 'R' project for statistical computing"
```

```{r eval = FALSE}
# double quotes within single quotes
'The "R" project for statistical computing'
```

However, we cannot directly insert single quotes in a string with single 
quotes, neither we can insert double quotes in a string with double quotes 
(Don't do this!):

```{r eval=FALSE}
"This "is" totally unacceptable"
```

```{r eval=FALSE}
'This 'is' absolutely wrong'
```

In both cases R will give you an error due to the unexpected presence of 
either a double quote within double quotes, or a single quote within single 
quotes.

If we really want to include a double quote as part of the string, we need 
to _escape_ the double quote using a backslash `\` before it:

```{r eval = FALSE}
"The \"R\" project for statistical computing"
```

We will talk more about escaping characters in the following chapters.


## Getting started with strings

Perhaps the most common use of character strings in R have to do with:

- names of files
- names of data objects
- text displayed in plots
  
When we read a file, for instance a data table stored in a csv file, 
we typically use the `read.table()` function and friends---e.g. `read.csv()`, 
`read.delim()`. Assuming that the file is in the working directory:

```{r eval = FALSE}
dat <- read.csv(file = 'dataset.csv')
```

The main parameter for the function `read.csv()` is `file` which requires a 
character string with the pathname of the file.

Another example of a basic use of characters is when we assign names to the 
elements of some data structure in R. For instance, if we have a (numeric) 
vector and we want to name its elements:

```{r eval = FALSE}
names(num_vec) <- str_vec
```

Likewise, many of the parameters in the plotting functions require some sort 
of input string. Below is a hypothetical example of a scatterplot that includes 
several graphical elements like the main title (`main`), subtitle (`sub`), 
labels for both x-axis and y-axis (`xlab`, `ylab`), the name of the color
(`col`), and the symbol for the point character (`pch`)

```{r eval = FALSE}
plot(x, y, 
     main = 'Main Title', 
     sub = 'Subtitle',
     xlab = 'x-axis label', 
     ylab = 'y-axis label',
     col = 'red', 
     pch = 'x')
```


## Creating Character Strings

Besides the single quotes `''` or double quotes `""`, R provides the function 
`character()` to create character strings. More specifically, `character()` 
is the function that creates vector objects of type `"character"`. 


### Empty string

Let's start with the most basic string: the __empty string__ produced by 
consecutive quotation marks: `""`. Technically, `""` is a string with 
no characters in it, hence the name "empty string":

```{r empty_string}
# empty string
empty_str <- ""
empty_str

# class
class(empty_str)
```


### Empty character vector

Another basic string structure is the __empty character vector__ produced 
by the function `character()` and its argument `length=0`:

```{r empty_char_vector}
# empty character vector
empty_chr <- character(0)
empty_chr

# class
class(empty_chr)
```

It is important not to confuse the empty character vector `character(0)` 
with the empty string `""`; one of the main differences between them is 
that they have different lengths:

```{r empty_str_char_lengths}
# length of empty string
length(empty_str)

# length of empty character vector
length(empty_chr)
```

Notice that the empty string `empty_str` has length 1, while the empty 
character vector `empty_chr` has length 0.

Also, `character(0)` occurs when we have a character vector with one or 
more elements, and we attempt to subset the position 0:

```{r sunny}
string <- c('sun', 'sky', 'clouds')
string
```

If we try to retrieve the element in position 0 we get:

```{r sunny0}
string[0]
```


### Function `c()`

There is also the generic function `c()` (concatenate or combine) that we 
can use to create character vectors. Simply pass any number of elements 
separated by commas:

```{r}
string <- c('sun', 'sky', 'clouds')
string
```

Again, notice that we can use single or double quotes to define the character 
elements inside `c()`

```{r}
planets <- c("mercury", 'venus', "mars")
planets
```


### Function `character()`

As we already mentioned, `character()` is a function to create character 
vectors. We just have to specify the length of the vector, and 
`character()` will produce a character vector with as many empty strings. 
For instance, to produce a character vector with five elements simply use 
`character(5)`:

```{r character_function}
# character vector with 5 empty strings
char_vector <- character(5)
char_vector
```

When would we use `character()`? A typical usage case is when we want to 
initialize a character vector of a given length. The idea is to create an 
object that we will modify later with some computation, but we require to have 
an object initialized already. 

Once an empty character object has been created, new components may be added to 
it simply by giving it an index value outside its previous range. 

```{r empty_vector_ex1}
# another example
example <- character(0)
example
# check its length
length(example)

# add first element
example[1] <- "first"
example
# check its length again
length(example)
```

We can add more elements without the need to follow a consecutive index range:

```{r empty_vector_ex2}
example[4] <- "fourth"
example
length(example)
```

Notice that we went from a one-element vector to a four-element vector without 
specifying the second and third elements. R fills this gap with missing 
values `NA`.


### `is.character()` and `as.character()`

Related to `character()` we have its two sister functions: 
`as.character()` and `is.character()`. These two functions are generic 
methos for creating objects of type `"character"` and testing whether an 
R object is of type `"character"`. For instance, let's define two 
objects `a` and `b` as follows:

```{r objs_a_b}
# define two objects 'a' and 'b'
a <- "test me"
b <- 8 + 9
```

To test if `a` and `b` are of type `"character"` use the function
`is.character()`:

```{r is_character}
# are 'a' and 'b' characters?
is.character(a)

is.character(b)
```

Likewise, you can also use the function `class()` to get the class of an 
object:

```{r class_a_b}
# classes of 'a' and 'b'
class(a)
class(b)
```

The function `as.character()` is a coercing method. For better or worse, 
R allows you to convert (i.e. coerce) non-character objects into character 
strings with the function `as.character()`:

```{r as_character}
# converting 'b' as character
b <- as.character(b)
b
```


## Behavior of R objects with character strings

The main, and most basic, type of objects in R are vectors. Vectors must have 
their values _all of the same mode_. This means that any given vector 
must be unambiguously either logical, numeric, complex, character or raw. 
In R we say that vectors are __atomic__ structures, with their elements 
having all the same type or mode. 

So what happens when we mix different types of data in a vector?

```{r mixed_vector}
# vector with numbers and characters
c(1:5, pi, "text")
```

As you can tell, the resulting vector from combining integers `1:5`, the 
number `pi`, and some `"text"` is a vector with all its elements 
treated as character strings. In other words, when we combine mixed data in 
vectors, strings will dominate. This means that the mode of the vector will be 
`"character"`, even if we mix logical values:

```{r mixed_vector2}
# vector with numbers, logicals, and characters
c(1:5, TRUE, pi, "text", FALSE)
```

In fact, R follows two basic rules of data types coercion. The most strict 
rule is: if a character string is present in a vector, everything else in the 
vector will be converted to character strings. The other coercing rule is: if a 
vector only has logicals and numbers, then logicals will be converted to 
numbers; `TRUE` values become 1, and `FALSE` values become 0.

Keeping these rules in mind will save you from many headaches and frustrating 
moments. Moreover, you can use them in your favor to manipulate data in very 
useful ways.


__Matrices.__
The same behavior of vectors happens when we mix characters and numbers in 
matrices. Again, everything will be treated as characters:

```{r mixed_matrix}
# matrix with numbers and characters
rbind(1:5, letters[1:5])
```

__Data frames.__
With data frames, things are a bit different. By default, character strings 
inside a data frame will be converted to factors:

```{r mixed_dataframe1}
# data frame with numbers and characters
df1 = data.frame(numbers=1:5, letters=letters[1:5])
df1
# examine the data frame structure
str(df1)
```

To turn-off the `data.frame()`'s default behavior of converting strings 
into factors, use the argument `stringsAsFactors = FALSE`:

```{r mixed_dataframe2, tidy=FALSE}
# data frame with numbers and characters
df2 <- data.frame(
  numbers = 1:5, 
  letters = letters[1:5], 
  stringsAsFactors = FALSE)

df2
# examine the data frame structure
str(df2)
```

Even though `df1` and `df2` are identically displayed, their structure is 
different. While `df1$letters` is stored as a `"factor"`, `df2$letters` is 
stored as a `"character"`.

__Lists.__
With lists, we can combine whatever type of data we want. The type of data in 
each element of the list will maintain its corresponding mode:

```{r mixed_list}
# list with elements of different mode
list(1:5, letters[1:5], rnorm(5))
```




